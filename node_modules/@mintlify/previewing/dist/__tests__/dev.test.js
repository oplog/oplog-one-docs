import { prebuild } from '@mintlify/prebuild';
import fse from 'fs-extra';
import isOnline from 'is-online';
import { mockProcessExit } from 'vitest-mock-process';
import { dev } from '../index.js';
import { downloadTargetMint, getTargetMintVersion } from '../local-preview/client.js';
import { run } from '../local-preview/run.js';
import * as utils from '../util.js';
const originalChdir = process.chdir;
vi.mock('fs-extra', () => {
    const mocks = {
        ensureDir: vi.fn().mockResolvedValue(undefined),
        pathExists: vi.fn().mockResolvedValue(true),
        readFileSync: vi.fn().mockReturnValue('1.0.0'),
        emptyDirSync: vi.fn().mockResolvedValue(undefined),
    };
    return {
        ...mocks,
        default: mocks,
    };
});
vi.mock('../local-preview/client.js', () => ({
    getTargetMintVersion: vi.fn().mockResolvedValue('1.0.0'),
    downloadTargetMint: vi.fn().mockResolvedValue(undefined),
}));
vi.mock('is-online', () => ({
    default: vi.fn().mockResolvedValue(true),
}));
vi.mock('@mintlify/prebuild', () => ({
    prebuild: vi.fn().mockResolvedValue(undefined),
}));
vi.mock('../local-preview/run.js', () => ({
    run: vi.fn().mockResolvedValue(undefined),
}));
vi.mock('../util.js', () => {
    const mockLogger = {
        text: '',
        succeed: vi.fn(),
        fail: vi.fn(),
        warn: vi.fn(),
        start: vi.fn(),
        stop: vi.fn(),
        stopAndPersist: vi.fn(),
    };
    return {
        buildLogger: vi.fn().mockReturnValue(mockLogger),
        maybeFixMissingWindowsEnvVar: vi.fn(),
    };
});
const prebuildMock = vi.mocked(prebuild);
const runMock = vi.mocked(run);
const buildLoggerMock = vi.mocked(utils.buildLogger);
const processExitMock = mockProcessExit();
const downloadTargetMintMock = vi.mocked(downloadTargetMint);
const defaultYargs = {
    _: [],
    $0: '',
    packageName: 'mintlify',
};
describe('dev', () => {
    beforeEach(() => {
        process.chdir = vi.fn();
        vi.clearAllMocks();
    });
    afterEach(() => {
        process.chdir = originalChdir;
    });
    it('happy path', async () => {
        await dev(defaultYargs);
        expect(buildLoggerMock).toHaveBeenCalledWith('Preparing local Mintlify instance...');
        expect(prebuildMock).toHaveBeenCalled();
        expect(buildLoggerMock().succeed).toHaveBeenCalledWith('Local Mintlify instance is ready. Launching your site...');
        expect(runMock).toHaveBeenCalled();
    });
    it('prebuild fails', async () => {
        const errorText = 'Some OpenAPI or docs.json schema error';
        prebuildMock.mockRejectedValueOnce(new Error(errorText));
        await dev(defaultYargs);
        expect(buildLoggerMock).toHaveBeenCalledWith('Preparing local Mintlify instance...');
        expect(buildLoggerMock().fail).toHaveBeenCalledWith(errorText);
        expect(processExitMock).toHaveBeenCalledWith(1);
    });
    it('fails if no existing client version and no internet', async () => {
        vi.mocked(isOnline).mockResolvedValueOnce(false);
        vi.mocked(fse.pathExists).mockResolvedValueOnce();
        await dev(defaultYargs).catch(() => { });
        expect(processExitMock).toHaveBeenCalledWith(1);
        expect(buildLoggerMock().fail).toHaveBeenCalledWith('Running mintlify dev after updating requires an internet connection.');
    });
    it('fails if no existing client version and no internet - mint command', async () => {
        vi.mocked(isOnline).mockResolvedValueOnce(false);
        vi.mocked(fse.pathExists).mockResolvedValueOnce();
        await dev({ ...defaultYargs, packageName: 'mint' }).catch(() => { });
        expect(processExitMock).toHaveBeenCalledWith(1);
        expect(buildLoggerMock().fail).toHaveBeenCalledWith('Running mint dev after updating requires an internet connection.');
    });
    it('has existing version but fails to get targetMintVersion', async () => {
        vi.mocked(isOnline).mockResolvedValueOnce(false);
        vi.mocked(getTargetMintVersion).mockResolvedValueOnce(undefined);
        await dev(defaultYargs);
        expect(buildLoggerMock().warn).toHaveBeenCalledWith('Failed to get latest Mintlify client version. Your current version is: 1.0.0, which may not be the latest Mintlify client version.');
        expect(prebuildMock).toHaveBeenCalled();
        expect(buildLoggerMock().succeed).toHaveBeenCalledWith('Local Mintlify instance is ready. Launching your site...');
        expect(runMock).toHaveBeenCalled();
    });
    it('downloads client with --client-version arg', async () => {
        await dev({ ...defaultYargs, 'client-version': '1.0.3' });
        expect(buildLoggerMock).toHaveBeenCalledWith('Preparing local Mintlify instance...');
        expect(downloadTargetMintMock).toHaveBeenCalled();
        expect(prebuildMock).toHaveBeenCalled();
        expect(buildLoggerMock().succeed).toHaveBeenCalledWith('Local Mintlify instance is ready. Launching your site...');
        expect(runMock).toHaveBeenCalled();
    });
    it('downloads client if no existing version', async () => {
        vi.mocked(fse.pathExists).mockResolvedValueOnce();
        await dev(defaultYargs);
        expect(buildLoggerMock).toHaveBeenCalledWith('Preparing local Mintlify instance...');
        expect(downloadTargetMintMock).toHaveBeenCalled();
        expect(prebuildMock).toHaveBeenCalled();
        expect(buildLoggerMock().succeed).toHaveBeenCalledWith('Local Mintlify instance is ready. Launching your site...');
        expect(runMock).toHaveBeenCalled();
    });
    it('warns about update if target version is different from existing version', async () => {
        vi.mocked(getTargetMintVersion).mockResolvedValueOnce('1.0.1');
        await dev(defaultYargs);
        expect(buildLoggerMock().warn).toHaveBeenCalledWith('An update is available. Run `mintlify update` to update to the latest version.');
        expect(prebuildMock).toHaveBeenCalled();
        expect(buildLoggerMock().succeed).toHaveBeenCalledWith('Local Mintlify instance is ready. Launching your site...');
        expect(runMock).toHaveBeenCalled();
    });
    it('warns about update if target version is different from existing version - mint command', async () => {
        vi.mocked(getTargetMintVersion).mockResolvedValueOnce('1.0.1');
        await dev({ ...defaultYargs, packageName: 'mint' });
        expect(buildLoggerMock().warn).toHaveBeenCalledWith('An update is available. Run `mint update` to update to the latest version.');
        expect(prebuildMock).toHaveBeenCalled();
        expect(buildLoggerMock().succeed).toHaveBeenCalledWith('Local Mintlify instance is ready. Launching your site...');
        expect(runMock).toHaveBeenCalled();
    });
});
